# wercker.yml for github.com/veritone/lambda-go

box: golang:1.10.0
no-response-timeout: 30
command-timeout: 30

build:
  steps:
    # known issue - resolved?
    # http://blog.wercker.com/publishing-go-binaries-with-wercker
    - script:
      name: provide chance for deployment
      code: |
        export ORG_SOURCE=$WERCKER_SOURCE_DIR

    - setup-go-workspace
    #- wercker/golint

    # Gets go version
    - script:
      name: go version
      code: |
        go version
        go env

    # Gets the dependencies for each function
    - script:
        name: go get recursive
        code: |
          cd $WERCKER_SOURCE_DIR
          for dir in *; do
            if [ -d "$dir" ]; then
              cd "$dir"
              go get -v
              echo "$dir deps $(date)"
              cd $WERCKER_SOURCE_DIR
            fi
          done
          cd $WERCKER_SOURCE_DIR

    # Build the projects
    - script:
        name: go build recursive
        code: |
          cd $WERCKER_SOURCE_DIR
          for dir in *; do
            if [ -f "$dir/main.go" ]; then
              cd "$dir"
              GOOS=linux go build -v
              echo "verifying binary... $(ls -la)"
              # Move binaries to OUTPUT_DIR to be artifacted
              cp -f "$dir" "$WERCKER_OUTPUT_DIR/$dir"
              cd $WERCKER_SOURCE_DIR
            fi
          done
          cd $WERCKER_SOURCE_DIR

deploy: 
  steps:
    # Install container dependencies
    - script:
      name: install deps
      code: |
        sudo apt-get update -y
        sudo apt-get upgrade -y
        sudo apt-get install -y wget zip unzip

    # Zip the project binaries
    - script:
        name: zip recursive
        code: |
          cd $WERCKER_SOURCE_DIR
          echo "verifying artifact directory... $(ls -la)" 
          for binary in *; do
            # will compress as name of binary
            if [ -f "$binary" ]; then
              zip "$binary.zip" "$binary"
            fi
          done
          echo "$(ls -la *.zip)" # see zips

    # Install aws-cli after binaries compressed
    - script:
        name: install aws-cli
        code: |
          if [ ! -f "$WERCKER_CACHE_DIR/awscli-bundle.zip" ]; then 
            wget https://s3.amazonaws.com/aws-cli/awscli-bundle.zip
            mv ./awscli-bundle.zip $WERCKER_CACHE_DIR
          fi
          unzip -o $WERCKER_CACHE_DIR/awscli-bundle.zip
          sudo ./awscli-bundle/install -i /usr/local/aws -b /usr/local/bin/aws

    # Send all the lambda functions to S3
    - script: 
        name: send zips to s3 bucket
        code: |
          cd $WERCKER_SOURCE_DIR
          for file in *.zip; do
            # will build as name of binary
            if [ -f "$file" ]; then
              echo "aws s3 cp $file s3://deployment-veritone/lambda/$file"
              aws s3 cp "$file" "s3://deployment-veritone/lambda/$file"
            fi
          done

    # Connects to Terraform via SSH and applies Lambda changes detected from S3
    # Is this more secure than giving 'wercker' user permissions to Lambda?
    - script:
        name: update functions via terraform
        code: |
          mkdir -p ~/.ssh/
          echo -e $TERRAFORM_PRIVATE_KEY > ~/.ssh/terraform_id_rsa
          chmod 600 ~/.ssh/terraform_id_rsa
          export MAKE_TARGET=lambda
          export VERITONE_ENVIRONMENT=global
          ssh -T -i ~/.ssh/terraform_id_rsa -o StrictHostKeyChecking=no terraform@0.terraform.aws-$ENVIRONMENT.veritone.com -o "SendEnv MAKE_TARGET VERITONE_*" 
